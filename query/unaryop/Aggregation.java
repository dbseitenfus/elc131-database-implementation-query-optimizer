/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package ibd.query.unaryop;

import ibd.query.ColumnDescriptor;
import ibd.query.Operation;
import ibd.query.UnpagedOperationIterator;
import ibd.query.ReferedDataSource;
import ibd.query.Tuple;
import ibd.query.unaryop.sort.Sort;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import ibd.table.prototype.Prototype;
import ibd.table.prototype.LinkedDataRow;
import ibd.table.prototype.column.DoubleColumn;
import ibd.table.prototype.column.IntegerColumn;
import ibd.table.prototype.column.StringColumn;

/**
 * This operation groups tuples and computes an aggregated value (MIN. MAX, SUM,
 * AVG, COUNT) for each group
 *
 * @author Sergio
 */
public class Aggregation extends UnaryOperation {

    //defines the five types of aggregation
    public final static int MAX = 1;
    public final static int MIN = 2;
    public final static int COUNT = 3;
    public final static int AVG = 4;
    public final static int SUM = 5;

    //the alias identifying the tuples generated by this operation
    String alias;

    //the group by column is used to group the incoming tuples
    ColumnDescriptor groupByColumn;
    //the aggregated column is used to perform the selected aggregation
    ColumnDescriptor aggregateColumn;

    //the index of the tuple that contains the group by column
    //int groupByTupleIndex = -1;
    //the index of the tuple that contains the aggregated column
    //int aggregatedTupleIndex = -1;
    //the aggregation type
    int type;

    //the schema of the rows returned by this operation
    Prototype prototype = null;

    /**
     *
     * @param op the operation to be connected with this unary operation
     * @param alias the alias identifying the tuples generated by this operation
     * @param groupByCol the name of the column to be used to group tuples. The
     * name can be prefixed by the table name (e.g. tab.col)
     * @param aggregateCol the name of the column to be used to aggregate values
     * from the grouped tuples. The name can be prefixed by the table name (e.g.
     * tab.col)
     * @param type the type of aggregation to be performed (AVG, COUNT, MIN,
     * MAX, SUM)
     * @param isOrdered indicates if the incoming tuples are already ordered by
     * the groupByCol column
     * @throws Exception
     */
    public Aggregation(Operation op, String alias, String groupByCol, String aggregateCol, int type, boolean isOrdered) throws Exception {
        super(op);
        this.alias = alias;
        groupByColumn = new ColumnDescriptor(groupByCol);
        aggregateColumn = new ColumnDescriptor(aggregateCol);
        this.type = type;
        prototype = new Prototype();
        prototype.addColumn(new StringColumn(groupByColumn.getColumnName(), (short)30));
        if (type == AVG) {
            prototype.addColumn(new DoubleColumn(getStringType(type) + "(" + aggregateColumn.getColumnName() + ")"));
            //prototype.addColumn(new DoubleColumn(aggregateColumn.getColumnName()));
        } else {
            prototype.addColumn(new IntegerColumn(getStringType(type) + "(" + aggregateColumn.getColumnName() + ")"));
            //prototype.addColumn(new IntegerColumn(aggregateColumn.getColumnName()));
        }
        prototype.validateColumns();

        //If the incoming tupled are not already sorted, an intermediary sort operation is added
        if (!isOrdered) {
            Sort cs = new Sort(childOperation, new String[]{groupByColumn.getColumnName()});
            childOperation = cs;
        }
    }

    /**
     *
     * @param op the operation to be connected into this unary operation
     * @param alias the alias identifying the tuples generated by this operation
     * @param groupByTable the name of the table to be used to group tuples
     * @param groupByCol the name of the column to be used to group tuples
     * @param groupedTable the name of the table to be used to aggregate values
     * from the grouped tuples.
     * @param groupedCol the name of the column to be used to aggregate values
     * from the grouped tuples.
     * @param type the type of aggregation to be performed (AVG, COUNT, MIN,
     * MAX, SUM)
     * @param isOrdered indicates if the incoming tuples are already ordered by
     * the groupByCol column
     * @throws Exception
     */
    public Aggregation(Operation op, String alias, String groupByTable, String groupByCol, String groupedTable, String groupedCol, int type, boolean isOrdered) throws Exception {
        super(op);
        this.alias = alias;
        groupByColumn = new ColumnDescriptor(groupByTable, groupByCol);
        aggregateColumn = new ColumnDescriptor(groupedTable, groupedCol);
        this.type = type;
        prototype = new Prototype();
        prototype.addColumn(new StringColumn(groupByColumn.getColumnName(), (short)30));
        if (type == AVG) {
            prototype.addColumn(new DoubleColumn(getStringType(type) + "(" + aggregateColumn.getColumnName() + ")"));
            //prototype.addColumn(new DoubleColumn(aggregateColumn.getColumnName()));
        } else {
            prototype.addColumn(new IntegerColumn(getStringType(type) + "(" + aggregateColumn.getColumnName() + ")"));
            //prototype.addColumn(new IntegerColumn(aggregateColumn.getColumnName()));
        }
        prototype.validateColumns();

        //If the incoming tupled are not already sorted, an intermediary sort operation is added
        if (!isOrdered) {
            Sort cs = new Sort(childOperation, new String[]{groupByColumn.getColumnName()});
            childOperation = cs;
        }
    }

    private String getStringType(int type) {
        return switch (type) {
            case AVG ->
                "AVG";
            case MIN ->
                "MIN";
            case MAX ->
                "MAX";
            case COUNT ->
                "COUNT";
            case SUM ->
                "SUM";
            default ->
                "";
        };
    }

    @Override
    public void prepare() throws Exception {

        //uses the table's names to set the tuple indexes 
        childOperation.setColumnLocation(groupByColumn);
        childOperation.setColumnLocation(aggregateColumn);

        //groupByTupleIndex = childOperation.getRowIndex(groupByColumn.getTableName());
        //aggregatedTupleIndex = childOperation.getRowIndex(aggregateColumn.getTableName());
        super.prepare();

    }

    /**
     * {@inheritDoc }
     * An aggregation defines its own schema. The schema of the rows coming into
     * an aggregation are combined into one, according to the type of
     * aggregation needed.
     *
     * @throws Exception
     */
    @Override
    public void setDataSourcesInfo() throws Exception {
        dataSources = new ReferedDataSource[1];
        dataSources[0] = new ReferedDataSource();
        dataSources[0].alias = alias;
        dataSources[0].prototype = prototype;

        childOperation.setDataSourcesInfo();
    }

    @Override
    public Iterator<Tuple> lookUp_(List<Tuple> processedTuples, boolean withFilterDelegation) {
        return new AggregationIterator(processedTuples, withFilterDelegation);
    }

    @Override
    public String toString() {
        String stringType = Aggregation.getType(type);
        return "Group by(" + groupByColumn.toString() + ")," + stringType + "(" + aggregateColumn + ")";
    }

    /**
     * this class produces resulting tuples from an aggregation over the child
     * operation
     */
    private class AggregationIterator extends UnpagedOperationIterator {

        //the iterator over the child operation
        Iterator<Tuple> tuples;
        Comparable prevGroupByValue;
        List<Integer> groupedValues = new ArrayList();

        public AggregationIterator(List<Tuple> processedTuples, boolean withFilterDelegation) {
            super(processedTuples, withFilterDelegation, getDelegatedFilters());

            tuples = childOperation.lookUp(processedTuples, false);//returns all tuples from the child operation 
        }

        private Comparable getValue(Tuple tp, ColumnDescriptor col) {
            return tp.rows[col.getColumnLocation().rowIndex].getValue(col.getColumnName());
        }

        @Override
        protected Tuple findNextTuple() {
            while (tuples.hasNext()) {
                Tuple tp = tuples.next();
                //a tuple must satisfy the lookup filter 
                if (!lookup.match(tp)) {
                    continue;
                }
                Comparable groupByValue = getValue(tp, groupByColumn);
                Comparable aggregatedValue = getValue(tp, aggregateColumn);

                if (prevGroupByValue == null) {
                    prevGroupByValue = groupByValue;

                    groupedValues.add((Integer) aggregatedValue);
                } else if ((prevGroupByValue.equals(groupByValue))) {
                    groupedValues.add((Integer) aggregatedValue);
                } else //if ((!prevGroupByValue.equals(groupByValue))) 
                {
                    Tuple tuple = new Tuple();
                    //BasicDataRow dataRow = new BasicDataRow();
                    LinkedDataRow dataRow = new LinkedDataRow(prototype, false);
                    dataRow.setValue(0, prevGroupByValue);
                    aggregate(dataRow, groupedValues);
                    //dataRow.setMetadata(prototype);
                    tuple.setSingleSourceRow(alias, dataRow);

                    prevGroupByValue = groupByValue;
                    groupedValues.clear();
                    groupedValues.add((Integer) aggregatedValue);
                    return tuple;
                }

            }
            if (prevGroupByValue != null) {
                Tuple tuple = new Tuple();
                LinkedDataRow dataRow = new LinkedDataRow(prototype, false);
                dataRow.setValue(0, prevGroupByValue);
                aggregate(dataRow, groupedValues);
                //dataRow.setMetadata(prototype);
                tuple.setSingleSourceRow(alias, dataRow);
                prevGroupByValue = null;
                return tuple;
            }

            return null;
        }

        private void aggregate(LinkedDataRow row, List<Integer> list) {
            switch (type) {
                case AVG -> {
                    row.setValue(1, avg(list));
                    return;
                }
                case MAX -> {
                    row.setValue(1, max(list));
                    return;
                }
                case MIN -> {
                    row.setValue(1, min(list));
                    return;
                }
                case COUNT -> {
                    row.setValue(1, count(list));
                    return;
                }
                case SUM -> {
                    row.setValue(1, sum(list));
                    return;
                }
            }

        }

        private Double avg(List<Integer> list) {

            if (list.isEmpty()) {
                return 0.;
            }
            int sum = 0;
            for (Integer integer : list) {
                sum += integer;
            }
            return Double.valueOf(sum / list.size());
        }

        private Integer sum(List<Integer> list) {

            int sum = 0;
            for (Integer integer : list) {
                sum += integer;
            }
            return sum;
        }

        private Integer min(List<Integer> list) {

            if (list.isEmpty()) {
                return 0;
            }
            int min = Integer.MAX_VALUE;
            for (Integer integer : list) {
                if (integer < min) {
                    min = integer;
                }
            }
            return min;
        }

        private Integer max(List<Integer> list) {

            if (list.isEmpty()) {
                return 0;
            }
            int max = Integer.MIN_VALUE;
            for (Integer integer : list) {
                if (integer > max) {
                    max = integer;
                }
            }
            return max;
        }

        private Integer count(List<Integer> list) {
            return list.size();
        }

    }

    public static final String getType(int type) {
        switch (type) {
            case AVG -> {
                return "AVG";
            }
            case MAX -> {
                return "MAX";
            }
            case MIN -> {
                return "MIN";
            }
            case COUNT -> {
                return "COUNT";
            }
            case SUM -> {
                return "SUM";
            }
        }
        return "";
    }

}
