/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package ibd.query.unaryop;

import ibd.query.ColumnDescriptor;
import ibd.query.Operation;
import ibd.query.UnpagedOperationIterator;
import ibd.query.ReferedDataSource;
import ibd.query.Tuple;
import ibd.query.unaryop.sort.Sort;

import java.util.HashMap;
import java.util.Iterator;
import java.util.List;

import ibd.table.prototype.LinkedDataRow;
import ibd.table.prototype.Prototype;
import ibd.table.prototype.column.DoubleColumn;
import ibd.table.prototype.column.IntegerColumn;
import ibd.table.prototype.column.StringColumn;

/**
 * This operation groups tuples and computes an aggregated value (MIN. MAX, SUM,
 * AVG, COUNT) for each group
 *
 * @author Sergio
 */
public class AggregationDanielSeitenfus extends UnaryOperation {

    //defines the five types of aggregation
    public final static int MAX = 1;
    public final static int MIN = 2;
    public final static int COUNT = 3;
    public final static int AVG = 4;
    public final static int SUM = 5;

    //the alias identifying the tuples generated by this operation
    String alias;

    //the group by column is used to group the incoming tuples
    ColumnDescriptor groupByColumn;
    //the aggregated column is used to perform the selected aggregation
    ColumnDescriptor aggregateColumn;

    //the index of the tuple that contains the group by column
    //int groupByTupleIndex = -1;
    //the index of the tuple that contains the aggregated column
    //int aggregatedTupleIndex = -1;
    //the aggregation type
    int type;

    //the schema of the rows returned by this operation
    Prototype prototype = null;

    //used to control tuple generation
    Comparable groupValue = null;
    int count = 0;
    int sum = 0;
    int min = 0, max = 0;

    /**
     *
     * @param op the operation to be connected with this unary operation
     * @param alias the alias identifying the tuples generated by this operation
     * @param groupByCol the name of the column to be used to group tuples. The
     * name can be prefixed by the table name (e.g. tab.col)
     * @param aggregateCol the name of the column to be used to aggregate values
     * from the grouped tuples. The name can be prefixed by the table name (e.g.
     * tab.col)
     * @param type the type of aggregation to be performed (AVG, COUNT, MIN,
     * MAX, SUM)
     * @param isOrdered indicates if the incoming tuples are already ordered by
     * the groupByCol column
     * @throws Exception
     */
    public AggregationDanielSeitenfus(Operation op, String alias, String groupByCol, String aggregateCol, int type, boolean isOrdered) throws Exception {
        super(op);
        this.alias = alias;
        groupByColumn = new ColumnDescriptor(groupByCol);
        aggregateColumn = new ColumnDescriptor(aggregateCol);
        this.type = type;
        prototype = new Prototype();
        prototype.addColumn(new StringColumn(groupByColumn.getColumnName(), (short)30));
        if (type == AVG) {
            prototype.addColumn(new DoubleColumn(getStringType(type) + "(" + aggregateColumn.getColumnName() + ")"));
            //prototype.addColumn(new DoubleColumn(aggregateColumn.getColumnName()));
        } else {
            prototype.addColumn(new IntegerColumn(getStringType(type) + "(" + aggregateColumn.getColumnName() + ")"));
            //prototype.addColumn(new IntegerColumn(aggregateColumn.getColumnName()));
        }
        prototype.validateColumns();

        //If the incoming tupled are not already sorted, an intermediary sort operation is added
        if (!isOrdered) {
            Sort cs = new Sort(childOperation, new String[]{groupByColumn.getColumnName()});
            childOperation = cs;
        }
    }

    /**
     *
     * @param op the operation to be connected into this unary operation
     * @param alias the alias identifying the tuples generated by this operation
     * @param groupByTable the name of the table to be used to group tuples
     * @param groupByCol the name of the column to be used to group tuples
     * @param groupedTable the name of the table to be used to aggregate values
     * from the grouped tuples.
     * @param groupedCol the name of the column to be used to aggregate values
     * from the grouped tuples.
     * @param type the type of aggregation to be performed (AVG, COUNT, MIN,
     * MAX, SUM)
     * @param isOrdered indicates if the incoming tuples are already ordered by
     * the groupByCol column
     * @throws Exception
     */
    public AggregationDanielSeitenfus(Operation op, String alias, String groupByTable, String groupByCol, String groupedTable, String groupedCol, int type, boolean isOrdered) throws Exception {
        super(op);
        this.alias = alias;
        groupByColumn = new ColumnDescriptor(groupByTable, groupByCol);
        aggregateColumn = new ColumnDescriptor(groupedTable, groupedCol);
        this.type = type;
        prototype = new Prototype();
        prototype.addColumn(new StringColumn(groupByColumn.getColumnName(), (short)30));
        if (type == AVG) {
            prototype.addColumn(new DoubleColumn(getStringType(type) + "(" + aggregateColumn.getColumnName() + ")"));
            //prototype.addColumn(new DoubleColumn(aggregateColumn.getColumnName()));
        } else {
            prototype.addColumn(new IntegerColumn(getStringType(type) + "(" + aggregateColumn.getColumnName() + ")"));
            //prototype.addColumn(new IntegerColumn(aggregateColumn.getColumnName()));
        }
        prototype.validateColumns();

        //If the incoming tupled are not already sorted, an intermediary sort operation is added
        if (!isOrdered) {
            Sort cs = new Sort(childOperation, new String[]{groupByColumn.getColumnName()});
            childOperation = cs;
        }
    }

    private String getStringType(int type) {
        return switch (type) {
            case AVG ->
                    "AVG";
            case MIN ->
                    "MIN";
            case MAX ->
                    "MAX";
            case COUNT ->
                    "COUNT";
            case SUM ->
                    "SUM";
            default ->
                    "";
        };
    }

    @Override
    public void prepare() throws Exception {

        //uses the table's names to set the tuple indexes 
        childOperation.setColumnLocation(groupByColumn);
        childOperation.setColumnLocation(aggregateColumn);

        //groupByTupleIndex = childOperation.getRowIndex(groupByColumn.getTableName());
        //aggregatedTupleIndex = childOperation.getRowIndex(aggregateColumn.getTableName());
        super.prepare();

    }

    /**
     * {@inheritDoc }
     * An aggregation defines its own schema. The schema of the rows coming into
     * an aggregation are combined into one, according to the type of
     * aggregation needed.
     *
     * @throws Exception
     */
    @Override
    public void setDataSourcesInfo() throws Exception {
        dataSources = new ReferedDataSource[1];
        dataSources[0] = new ReferedDataSource();
        dataSources[0].alias = alias;
        dataSources[0].prototype = prototype;

        childOperation.setDataSourcesInfo();
    }

    @Override
    public Iterator<Tuple> lookUp_(List<Tuple> processedTuples, boolean withFilterDelegation) {
        return new AggregationIterator(processedTuples, withFilterDelegation);
    }

    @Override
    public String toString() {
        String stringType = AggregationDanielSeitenfus.getType(type);
        return "Group by(" + groupByColumn.toString() + ")," + stringType + "(" + aggregateColumn + ")";
    }

    /**
     * this class produces resulting tuples from an aggregation over the child
     * operation
     */
    private class AggregationIterator extends UnpagedOperationIterator {
        HashMap<String, Double> hashMap;
        //the iterator over the child operation
        Iterator<Tuple> tuples;

        public AggregationIterator(List<Tuple> processedTuples, boolean withFilterDelegation) {
            super(processedTuples, withFilterDelegation, getDelegatedFilters());

            tuples = childOperation.lookUp(processedTuples, false);//returns all tuples from the child operation
            hashMap = new HashMap<>();
        }

        private Comparable getValue(Tuple tp, ColumnDescriptor col) {
            return tp.rows[col.getColumnLocation().rowIndex].getValue(col.getColumnName());
        }

        private int getInt(Tuple tp, ColumnDescriptor col) {
            return tp.rows[col.getColumnLocation().rowIndex].getInt(col.getColumnName());
        }

        private boolean isColumnString(Tuple tp, ColumnDescriptor col) {
            return tp.rows[col.getColumnLocation().rowIndex].getPrototype().getColumn(col.getColumnName()).isString();
        }

        @Override
        protected Tuple findNextTuple() {
            while (tuples.hasNext()) {
                Tuple tp = tuples.next();

                //a tuple must satisfy the lookup filter
                if (!lookup.match(tp)) {
                    continue;
                }

                Comparable tupleGroup = getValue(tp, groupByColumn);

                int aggregationValue = 0;
                if(!isColumnString(tp, aggregateColumn)) {
                    aggregationValue = getInt(tp, aggregateColumn);
                }

                if(isTheFirstGroup()) {
                    groupValue = tupleGroup;
                    initiateVariables(aggregationValue, type);
                } else if (groupValue.compareTo(tupleGroup) == 0) {
                    updateAggregation(aggregationValue);
                } else {
                    Tuple newTuple = generateTuple(aggregationValue);
                    groupValue = tupleGroup;
                    initiateVariables(aggregationValue, type);
                    return newTuple;
                }
            }

            if(hasTupleToReturn()) {
                Tuple newTuple = generateTuple(0);
                groupValue = null;
                count = 0;
                sum = 0;
                min = 0;
                max = 0;
                return newTuple;
            }

            return null;
        }

        private boolean isTheFirstGroup() {
            return groupValue == null;
        }

        private boolean hasTupleToReturn() {
            return count > 0;
        }

        private void updateAggregation(int aggregationValue) {
            count++;
            if(type == AVG || type == SUM) {
                sum += aggregationValue;
            } else if(type == MIN) {
                if(aggregationValue < min) {
                    min = aggregationValue;
                }
            } else if(type == MAX) {
                if(aggregationValue > max) {
                    max = aggregationValue;
                }
            }
        }

        private void initiateVariables(int aggregationValue, int type) {
            count = 1;
            if(type == AVG || type == SUM) {
                sum = aggregationValue;
            } else if(type == MIN) {
                min = aggregationValue;
            } else if(type == MAX) {
                max = aggregationValue;
            }
        }

        private Tuple generateTuple(int aggregationValue) {
            LinkedDataRow dataRow = new LinkedDataRow(prototype, false);
            dataRow.setString(0, groupValue.toString());
            if(type == AVG) {
                double result = sum == 0 || count == 0 ? 0 : (double) sum/count;
                dataRow.setValue(1, result);
            } else if(type == SUM) {
                dataRow.setValue(1, sum);
            } else if (type == COUNT) {
                dataRow.setValue(1, count);
            } else if (type == MIN) {
                dataRow.setValue(1, min);
                min = aggregationValue;
            } else if(type == MAX) {
                dataRow.setValue(1, max);
                max = aggregationValue;
            }

            Tuple newTuple = new Tuple();
            newTuple.setSingleSourceRow(alias, dataRow);
            return newTuple;
        }

    }

    public static final String getType(int type) {
        switch (type) {
            case AVG -> {
                return "AVG";
            }
            case MAX -> {
                return "MAX";
            }
            case MIN -> {
                return "MIN";
            }
            case COUNT -> {
                return "COUNT";
            }
            case SUM -> {
                return "SUM";
            }
        }
        return "";
    }
}